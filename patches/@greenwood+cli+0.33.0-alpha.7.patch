diff --git a/node_modules/@greenwood/cli/src/lib/walker-package-ranger.js b/node_modules/@greenwood/cli/src/lib/walker-package-ranger.js
index 180b758..c6f2f0a 100644
--- a/node_modules/@greenwood/cli/src/lib/walker-package-ranger.js
+++ b/node_modules/@greenwood/cli/src/lib/walker-package-ranger.js
@@ -9,7 +9,7 @@ const diagnostics = new Map();
 
 function updateImportMap(key, value, resolvedRoot) {
   importMap.set(
-    key.replace("./", ""),
+    key.replace("./", "").replace(/\/\//g, '/'),
     `${IMPORT_MAP_RESOLVED_PREFIX}${resolvedRoot.replace("file://", "")}${value.replace("./", "")}`,
   );
 }
@@ -121,43 +121,22 @@ function patternRoot(pattern) {
  *  "./*": { "default": "./dist/*.ts.js" } - https://unpkg.com/browse/signal-utils@0.21.1/package.json
  */
 async function walkExportPatterns(dependency, sub, subValue, resolvedRoot) {
-  // find the "deepest" segment we can start from to avoid unnecessary file scanning / crawling
-  const rootSubOffset = patternRoot(sub);
-  const rootSubValueOffset = patternRoot(subValue);
-
-  // ideally we can use fs.glob when it comes out of experimental
-  // https://nodejs.org/docs/latest-v22.x/api/fs.html#fspromisesglobpattern-options
-  function walkDirectoryForExportPatterns(directoryUrl) {
-    const filesInDir = fs.readdirSync(directoryUrl);
-
-    filesInDir.forEach((file) => {
-      const filePathUrl = new URL(`./${file}`, directoryUrl);
-      const stat = fs.statSync(filePathUrl);
-      const pattern = `${resolvedRoot}${subValue.replace("./", "")}`;
-      const regexPattern = globToRegex(pattern);
-
-      if (stat.isDirectory()) {
-        walkDirectoryForExportPatterns(new URL(`./${file}/`, directoryUrl));
-      } else if (regexPattern.test(filePathUrl.href)) {
-        const relativePath = filePathUrl.href.replace(resolvedRoot, "");
-        // naive way to offset a subValue pattern to the sub pattern when dealing with wildcards
-        // ex. "./js/*": "./packages/*/src/index.js" -> /js/<package-name>/src/index.js
-        const rootSubRelativePath = sub.endsWith("*")
-          ? `./${relativePath}`
-              .replace(subValue.split("*")[0], "")
-              .replace(subValue.split("*")[1], "")
-          : relativePath.replace(rootSubValueOffset, "");
-
-        updateImportMap(
-          `${dependency}${rootSubOffset}/${rootSubRelativePath}`,
-          relativePath,
-          resolvedRoot,
-        );
-      }
-    });
-  }
+  // TODO cleanup
+  const sv1 = subValue.startsWith('/') ? subValue.replace('/', '') : subValue;
+  const sv2 = sv1 !== '*' && subValue.endsWith('*') ? `${subValue}*` : subValue;
+  console.log('$$$$', { subValue, sv1, sv2 })
+
+  const matches = fs.promises.glob(
+    sv2,
+    { cwd: new URL(resolvedRoot).pathname },
+  );
 
-  walkDirectoryForExportPatterns(new URL(`.${rootSubValueOffset}/`, resolvedRoot));
+  for await (const match of matches) {
+    const filePathUrl = new URL(`./${match}`, resolvedRoot);
+    const relativePath = filePathUrl.href.replace(resolvedRoot, "");
+
+    updateImportMap(`${dependency}/${match}`, relativePath, resolvedRoot);
+  }
 }
 
 function trackExportConditions(dependency, exports, sub, condition, resolvedRoot) {
@@ -225,7 +204,42 @@ async function walkPackageForExports(dependency, packageJson, resolvedRoot) {
        * 2. module-sync
        * 3. default
        */
-      if (typeof exports[sub] === "object") {
+      if(Array.isArray(exports[sub])) {
+        // console.log('?????????');
+        for (const item of exports[sub]) {
+          // console.log({ item })
+          // TODO if string, just check it in...
+          if(typeof item === 'object') {
+            // console.log('this is a new one....')
+            let matched = false;
+
+            for (const condition of SUPPORTED_EXPORT_CONDITIONS) {
+              if (item[condition]) {
+                matched = true;
+                // console.log('item[condirtion]', item[condition])
+                // console.log({ dependency, exports, sub, condition, resolvedRoot });
+                if (sub.indexOf("*") >= 0) {
+                  // TODO
+                  // await walkExportPatterns(dependency, sub, item[condition], resolvedRoot);
+                } else {
+                  // TODO 
+                  // const suffix = sub === "." ? "" : sub
+                  updateImportMap(dependency, item[condition], resolvedRoot);
+                }
+                break;
+              }
+            }
+  
+            if (!matched) {
+              // ex. https://unpkg.com/browse/matches-selector@1.2.0/package.json
+              diagnostics.set(
+                dependency,
+                `no supported export conditions (\`${SUPPORTED_EXPORT_CONDITIONS.join(", ")}\`) for dependency => \`${dependency}\``,
+              );
+            }
+          }
+        }
+      } else if (typeof exports[sub] === "object") {
         let matched = false;
 
         for (const condition of SUPPORTED_EXPORT_CONDITIONS) {
@@ -268,7 +282,18 @@ async function walkPackageForExports(dependency, packageJson, resolvedRoot) {
       }
     }
   } else if (module || main) {
-    updateImportMap(dependency, `${module ?? main}`, resolvedRoot);
+    if (main) {
+      const root = main.split('/').slice(0, -1).join('/');
+      // console.log({ main, root });
+      // const relativeRoot = root.startsWith('.')
+      //   ? root
+      //   : `./${root}`;
+      // console.log({ relativeRoot, resolvedRoot });
+      updateImportMap(dependency, main, resolvedRoot);
+      await walkExportPatterns(dependency, '', `${root}/*`, resolvedRoot);
+    } else {
+      updateImportMap(dependency, module, resolvedRoot);
+    }
   } else if (fs.existsSync(new URL("./index.js", resolvedRoot))) {
     // if an index.js file exists but with no main entry point, then it should count as a main entry point
     // https://docs.npmjs.com/cli/v7/configuring-npm/package-json#main
